# frozen_string_literal: true

require "spec_helper"

RSpec.describe do
  it "analyzes correct file" do
    status, info = PngCheck.analyze_file("spec/examples/correct.png")
    expect(status).to eql PngCheck::STATUS_OK
    expect(info).to include "OK"
  end

  it "analyzes correct file from PlantUML" do
    status, info = PngCheck.analyze_file("spec/examples/correct2.png")
    expect(status).to eql PngCheck::STATUS_OK
    expect(info).to include "OK"
    #    puts "--> info: #{info}\n"
  end

  it "sets STATUS_WARNING for MacOS screenshot" do
    status, info = PngCheck.analyze_file("spec/examples/macos-screenshot.png")
    expect(status).to eql PngCheck::STATUS_WARNING
    expect(info).to include "illegal (unless recently approved) unknown"
    #    puts "--> info: #{info}\n"
  end

  it "analyzes broken file" do
    status, info = PngCheck.analyze_file("spec/examples/corrupt.png")
    expect(status).to eql PngCheck::STATUS_MAJOR_ERROR
    expect(info).to include "data error"
    #    puts "--> info: #{info}\n"
  end

  it "analyzes missing file" do
    status, info = PngCheck.analyze_file("spec/examples/nofile.png")
    expect(status).to eql PngCheck::STATUS_CRITICAL_ERROR
    expect(info).to include "No such file or directory"
    #    puts "--> info: #{info}\n"
  end

  it "returns true on correct file check" do
    expect(PngCheck.check_file("spec/examples/correct.png")).to eql true
  end

  it "returns true on correct file from PlantUML check" do
    expect(PngCheck.check_file("spec/examples/correct2.png")).to eql true
  end
  it "raises an exception on corrupt file check" do
    PngCheck.check_file("spec/examples/corrupt.png")
    expect(false).to be true
  rescue PngCheck::CorruptPngError => e
    expect(e.status).to eql PngCheck::STATUS_MAJOR_ERROR
  end

  it "raises an exception on empty file check" do
    PngCheck.check_file("spec/examples/empty.png")
    expect(false).to be true
  rescue PngCheck::EmptyPngError => e
    expect(e.status).to eql PngCheck::STATUS_CRITICAL_ERROR
  end

  it "raises an exception on missing file check" do
    PngCheck.check_file("spec/examples/nofile.png")
    expect(false).to be true
  rescue PngCheck::CorruptPngError => e
    expect(e.status).to eql PngCheck::STATUS_CRITICAL_ERROR
  end

  it "analyzes correct buffer" do
    encoded = File.binread("spec/examples/correct.png")
    status, info = PngCheck.analyze_buffer(encoded)
    expect(status).to eql PngCheck::STATUS_OK
    expect(info).to include "OK"
  end

  it "analyzes correct buffer generated by PlantUML" do
    encoded = File.binread("spec/examples/correct2.png")
    status, info = PngCheck.analyze_buffer(encoded)
    expect(status).to eql PngCheck::STATUS_OK
    expect(info).to include "OK"
  end

  it "analyzes corrupt buffer" do
    encoded = File.binread("spec/examples/corrupt.png")
    status, info = PngCheck.analyze_buffer(encoded)
    expect(status).to eql PngCheck::STATUS_MAJOR_ERROR
    expect(info).to include "data error"
  end

  it "analyzes trash in a buffer" do
    encoded = "[this is just a string]"
    status, info = PngCheck.analyze_buffer(encoded)
    expect(status).to eql PngCheck::STATUS_CRITICAL_ERROR
    expect(info).to include "neither a PNG or JNG image nor a MNG stream"
  end

  it "returns true on correct buffer check" do
    encoded = File.binread("spec/examples/correct.png")
    expect(PngCheck.check_buffer(encoded)).to eql true
  end

  it "returns true on correct buffer generated by PlantUML check" do
    encoded = File.binread("spec/examples/correct2.png")
    expect(PngCheck.check_buffer(encoded)).to eql true
  end

  it "sets STATUS_WARNING for a buffer generated from MacOS screenshot" do
    encoded = File.binread("spec/examples/macos-screenshot.png")
    status, info = PngCheck.analyze_buffer(encoded)
    expect(status).to eql PngCheck::STATUS_WARNING
    expect(info).to include "illegal (unless recently approved) unknown"
  end

  it "raises an exception on corrupt buffer check" do
    encoded = File.binread("spec/examples/corrupt.png")
    PngCheck.check_buffer(encoded)
    expect(false).to be true
  rescue PngCheck::CorruptPngError => e
    expect(e.status).to eql PngCheck::STATUS_MAJOR_ERROR
  end

  it "raises an exception on trash buffer check" do
    encoded = "[this is just a string]"
    PngCheck.check_buffer(encoded)
    expect(false).to be true
  rescue PngCheck::CorruptPngError => e
    expect(e.status).to eql PngCheck::STATUS_CRITICAL_ERROR
  end

  it "raises an exception on empty buffer check" do
    encoded = ""
    PngCheck.check_buffer(encoded)
    expect(false).to be true
  rescue PngCheck::EmptyPngError => e
    expect(e.status).to eql PngCheck::STATUS_CRITICAL_ERROR
  end

  it "raises an exception(STATUS_WARNING) on macos screenshot" do
    encoded = File.binread("spec/examples/macos-screenshot.png")
    PngCheck.check_buffer(encoded)
    expect(false).to be true
  rescue PngCheck::CorruptPngError => e
    expect(e.status).to eql PngCheck::STATUS_WARNING
  end

  begin
    require "png"
    it "can be used with libpng-ruby" do
      encoded = File.binread("spec/examples/correct.png")
      begin
        expect(PngCheck.check_buffer(encoded)).to eql true
        dec = PNG::Decoder.new
        raw = dec << encoded
      rescue PngCheck::CorruptPngError => e
        puts "Exception #{e.message}"
      end
      f = "aaaaaaaaa"
      expect(raw.unpack(f)).to start_with
      "\xF4\xD1\r\xF4\xD1\r\xF4\xD1\r\xF4".unpack(f)
    end
  rescue LoadError
    puts "Failed to load libpng-ruby, skipping compatibility test"
  end
end
